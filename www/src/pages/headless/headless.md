---
title: Headless
layout: layouts/docsWithContentNav.njk
permalink: /headless/ 
eleventyNavigation:
    key: headless 
    title: Headless Components 
    order: 20
    icon: puzzle
    classes: "font-bold capitalize"
---

Anstelle des klassischen Ansatzes, fertige und dabei vollständig funktionale und durchgestylte Komponenten anzubieten,
setzt fritz2 auf einen anderen Weg: Sogenannte *Headless*-Komponenten.

Diese stellen im Grunde ein Baukastensystem dar, mit dessen Hilfe sich ein Benutzer selber auf einfache Art und Weise
Oberflächen mit typischen Funktionalitäten bauen kann. Dazu gehören z.B. Funktionen wie die Mehrfach- oder auch
Einfachauswahl von Elementen aus einer gegebenen Liste dar, modale Dialoge, Popup-Fenster, Eingabefelder uvm.

Die reine Funktionalität solcher Elemente, insbesondere die Benutzerinteraktion und das entsprechende Datenhandling,
wie etwa das Navigieren innerhalb einer Auswahlliste oder ein Mausklick auf einen Schalter, wird durch die 
Headless-Komponenten gekapselt. Der Benutzer muss sich nur noch um die reine Darstellung kümmern, also die Struktur
der benötigten Tags und das Styling.

Für Hintergrundinformationen, wieso wir Headless-Komponenten für den optimalen Weg halten, dem Benutzer von fritz2 
solche funktionalen Bausteine zur Verfügung zu stellen, verweisen wir auf einen detaillierten
[Blog-Eintrag](missing-headless-why).

::: info
**Hinweis:** für die Styling-Angaben verwenden wir in den Beispielen das [tailwindcss](https://tailwindcss.com/)
Framework. Da fritz2 agnostisch bezüglich der Styling-Angaben ist, kannst Du natürlich auch andere Frameworks wie
[Bootstrap](https://getbootstrap.com/) oder natürlich auch plain CSS verwenden.
:::

## Struktur einer Komponente

Jede Komponente wird über eine Fabrik-Funktion erzeugt. In seltenen Fällen gibt es auch Varianten von Fabrik-Funktionen
(z.B. bei [switch](switch/#switchwithlabel)). Das Wort "Komponente" bezeichnet daher im folgenden auch immer
gleichzeitig die zugehörige Fabrik-Funktion und umgekehrt.

Komponenten wiederum bestehen aus weiteren, sich oftmals tiefer verschachtelnden Bausteinen. Diese werden analog durch
Fabrik-Funktionen erzeugt.

Alle Komponenten und viele Bausteine besitzen einen eigenen *Scope*, in dem der Benutzer eine bestimmte *Konfiguration*
vornehmen muss, um die Funktionalität einer Komponente zu nutzen. Für eine solche Konfiguration gibt es im Wesentlichen
drei verschiedene Konzepte: einfache `var`-Felder (im folgenden auch "einfache Konfiguration" genannt),
[`Property`s](#properties) und [`Hook`s](#hooks). Alle drei ermöglichen es dem Benutzer, die Struktur, das Verhalten
und allgemein die Funktion einer Komponente sinnvoll an den Kontext anzupassen. Auf die genaue Funktionsweise der
drei Konfigurationen wird in den verlinkten Abschnitten genauer eingegangen.

Fast ausnahmslos erzeugen alle Fabriken (von Komponenten und Bausteinen) immer auch einen `Tag`. Dem Benutzer
stehen folglich alle Attribute des erzeugten Tags zur Verfügung, wie z.B. `className` oder auch `attr`!

```kotlin
someComponent(/* params */) {
    // Scope von `someComponent` == some `Tag` + specific extra props (`initialize`-Parameter)

    someBrick(/* params */) {
        // Scope von `SomeBrick` == some `Tag` + specific extra props + props from outer Scope! (`initialize`-Parameter)
    }
}
```

Bausteine haben als Präfix immer den markanten Teil oder auch den vollständigen Namen der Komponente zu der sie gehören,
z.B. `radioGroupLabel` für eine Beschriftung innerhalb der `radioGroup` Komponente.

Fast alle Fabrik-Funktionen von Komponenten und Bausteinen haben dieselbe Signatur, die bewusst der eines `Tags`
ähnlich ist:

```kotlin
fun <C : HTMLElement> RenderContext.someComponent(
    classes: String? = null, // modify the styling
    id: String? = null, // set an explicit ID; will be autogenerated in cases where this is needed
    scope: (ScopeContext.() -> Unit) = {}, // set some key-value-pairs into the scope
    tag: TagFactory<Tag<C>>, // provide a factory to create some `Tag<C>` (there is *always* an overloaded function with some default `Tag`) 
    initialize: SomeComponent<C>.() -> Unit // the builder function, that enables the component designer to define the content and access the scope of a component / brick
): Tag<C>
```

In den API-Sektionen der Komponenten werden diese Standard-Parameter nur als knappe, typ-lose Aufzählung gelistet.
Oftmals fehlt bei Bausteinen die Möglichkeit, eine ID explizit zu setzen.

Wichtiger sind hingegen *zusätzliche* Parameter, die der ein oder andere Baustein benötigt. Diese sind daher bewusst
beschrieben und damit leicht zu erkennen. Zumeist sind das entsprechend auch Pflichtparameter.

## API-Beschreibung

Da jede Komponente aus vielen verschiedenen Bausteinen besteht und diese wiederum selber einige Felder mit `Hook`s,
`Property`s oder auch einfachen `var`-Typen anbieten, wird eine stark abstrahierende Übersicht geboten. Diese fokussiert
sich auf die speziellen Headless-Aspekte und deutet per Kommentar auch hilfreiche Muster an. Standard-Parameter oder
Felder der Default-Tags werden hingegen ausgespart.

Folgendes Beispiel soll die Darstellung zeigen. Zur Verdeutlichung sind die Strukturen hier zusätzlich kommentiert; in
den Komponenten-Dokumentationen fehlen diese Meta-Informationen.

```kotlin
// Komponenten Fabrik
someComponent() {
    // Felder
    val value: DatabindingProperty<Int>
    var visibleItems: Int

    // Bausteine
    someBrick() { }
    someOtherBrick() {
        // eigener Scope mit eigenen Feldern und Sub-Bausteinen
        val msgs: Flow<List<Messages>>
    }
    // Andeutung eines relevanten Musters:
    // for each item {
    someRepeatingBrick(item: T) {
        //                 ^^^^^^^
        //                 mandatory additional parameter!

        // eigenes Feld
        val selected: Flow<Boolean>
    }
    // }

}
```

## UI = Headless + Tags + Styling

Um aus den Headless Komponenten und deren Bausteinen eine funktionierendes UI zu erzeugen, müssen die gegebenen
Fabrik-Funktionen derartig ineinander geschachtelt und mit weiteren `Tags` kombiniert werden, dass die gewünschte
Gesamtstruktur entsteht. Zusätzlich muss das Aussehen über das Hinzufügen von Styling definiert werden.

Die Headless-Komponenten und -Bausteine bieten dabei folgende Ansatzpunkte, um Funktion und Darstellung der Komponente 
zu definieren:

- Verwendung eines bestimmten Bausteins
- Bestimmen des zu erzeugenden `Tag`s in den Fabrik-Funktionen
- Setzen von Styling-Angaben in den Fabrik-Funktionen
- Konfiguration im Scope der Komponente oder des Bausteins

### Verwendung eines bestimmten Bausteins

Bausteine besitzen oftmals in sich eine Funktionalität, die alleine durch deren Verwendung innerhalb einer Komponente
aktiviert wird. Beispiele dafür sind die diversen `*Label`, die idR. bestimmte
[ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) Attribute setzen oder auch etablierte Funktionen
auslösen.

Ein gutes Beispiel dafür sind die Labels bei den Text-Komponenten [InputField](#inputField) und [TextArea](#textArea).
Werden diese verwendet, so fokussiert ein Maus-Klick auf diese Elemente automatisch das zugehörige Eingabefeld.

Diese Funktion ist ohne weiteres Zutun des Benutzers verfügbar, sobald der entsprechende `*Label`-Baustein im
Scope der Komponente aufgerufen wird.

Weitere Beispiele finden sich in den diversen `*Toggle`-Bausteinen (wie z.B.
[checkboxGroupOptionToggle](checkboxgroup/#checkboxgroupoptiontoggle)), die automatisch das Selektieren / Deselektieren
von Items aufgrund von definierten Benutzer-Eingaben vornehmen. Der Designer muss nichts weiter tun, als diese Bausteine
entsprechend in seiner Komponente zu "platzieren".

### Bestimmen des zu erzeugenden `Tag`s in den Fabrik-Funktionen

Die Headless-Komponenten und deren Bausteine bieten immer einen guten Default-Typen für das zu erzeugende `Tag` an. Um
aber die größt mögliche Flexibilität zu erreichen, kann der Benutzer den Typen des Tags frei wählen.

So kann er das für den Kontext semantisch passende Tag erzeugen.

Auch hier können wieder die `*Label`-Attribute als Beispiel dienen. Diese erzeugen zumeist tatsächlich HTML
`label`-Tags. Eine einfache Angabe des `tag`-Parameter genügt jedoch, um dieses Verhalten zu überschreiben:

```kotlin
inputField() {
    inputFieldLabel(tag = RenderContext::span) { // Scope von `HTMLSpanElement`
        +"Some Label Text"
    }
}
```

### Setzen von Styling-Angaben in den Fabrik-Funktionen

Fast jede Fabrik-Funktion akzeptiert einen `classes`-Parameter, mit welchem beliebige CSS-Klassen an den zu erzeugenden
`Tag` gesetzt werden können. Damit kann der Benutzer einfach die Darstellung bestimmen. Dies ist umso wichtiger,
als dass das Styling fast immer im Gesamtkontext der Komponente zu sehen ist.

```kotlin
inputField() {
    inputFieldLabel("text-indigo-500 p-8 mh-4") {
        //           ^^^^^^^^^^^^^^^^^^^^^^^^
        //           Some Styling, almost always first parameter
        +"Some Label Text"
    }
}
```

### Konfiguration im Scope der Komponente oder des Bausteins

Als letzter und dafür auch extrem mächtiger Aspekt stellen die Komponenten und Bausteine öffentlich zugängliche Felder
für den Anwender bereit, durch die dieser die Konfiguration vornehmen kann oder sogar muss.

Zur Erinnerung: Die drei gängigen Konzepte zur Konfiguration ist die einfache Konfiguration über `public var`-Felder,
[`Property`s](#properties) und [`Hook`s](#hooks).

In diesen Feldern wird dem Benutzer oftmals Zugriff auf einen aktuellen Status gegeben, oder dieser kann
bestimmen, wie der Status ggf. geändert werden soll. Die (Zwei-Wege-)Datenbindung findet z.B. *immer* über eine
entsprechende `Property` statt, die vom Designer gefüllt werden muss. Dies umfasst z.B. die Informationen über die
Selektion bei den Auswahlkomponenten ([RadioGroup](radioGroup), [CheckboxGroup](checkboxGroup) oder
[ListBox](listBox)), aber auch die Eingabewerte bei Textfeld-Komponenten ([InputField](inputField)
und [TextArea](textArea)).

Dazu kommen auch oftmals bestimmte `Flow`s und `Handler`, über welche man spezielle Zustände (selektiert, disabled,
fokussiert oder geöffnet) abfragen oder entsprechend auch das Verhalten bei Änderungen (Anwender klickt auf einen
*close*-Button) definieren kann.

Typische Muster sind das dynamische Setzen von CSS-Klassen in Abhängigkeit eines bestimmten Zustands über `className`
oder auch das komplette Erzeugen oder Löschen von DOM-Strukturen:

```kotlin
checkboxGroup {
    // Special Databinding-Property for the selection management.
    // Component will automatically use the current selections and also set or remove those by user interaction. 
    value(someStore)

    checkboxGroupOption(option) {
        // offers `selected: Flow<Boolean>` property -> style checked and unchecked options differently
        className(selected.map {
            if (it) "ring-2 ring-indigo-500 border-transparent"
            else "border-gray-300"
        })

        // Conditionally modify a whole sub-structure: Show an Icon only if option is selected
        selected.render {
            if (it) {
                svg("h-5 w-5 text-indigo-600") {
                    content(HeroIcons.check_circle)
                    fill("currentColor")
                }
            }
        }
    }
}
```

## Basiskonzepte für die Konfiguration

Headless Komponenten und Bausteine benötigen unabhängig von der konkreten Ausprägung oftmals ähnliche Mechanismen, wie
sie bestimmte Daten von einem Benutzer einfordern und verwalten. Über das reine Datenmanagement hinaus, muss es dem
Benutzer auch möglich sein, direkt in das Rendering einzugreifen und individuelles Verhalten in die Komponente oder den
Baustein hineinzureichen.

Dafür existieren zwei Grundkonzepte, die im folgenden genauer vorgestellt werden sollen:
- Properties
- Hooks

Da die Datenanbindung besonders wichtig ist, wird diese spezielle Implementierung einer `Property` separat in einem
Abschnitt erläutert.

### Properties

Eine `Property` dient als Container für Daten, die von einer Komponente oder einem Baustein für die Erfüllung seiner 
Aufgabe relevant sind und vom Anwender von außen konfiguriert werden können oder müssen. Die Property wird entsprechend
immer von der jeweiligen Headless-Instanz angelegt und in ihrem Scope dem Benutzer exponiert.

Um dieses öffentliche API so passend wie möglich zu schneiden, sieht das Konzept vor, die benötigten Daten mittels
`invoke`-Methode einzufordern, die dann intern den Datensatz ablegen. Daraus ergibt sich automatisch, dass das öffentliche
API zum Setzen von Daten immer eindeutig und einheitlich definiert ist. Zusätzlich wird es einfach möglich, Überladungen
für gängige Fälle anzubieten, wenn solche Daten heterogen vorliegen können:

```kotlin
class UserProperty : Property<User>() {
    // Only visible "modifying" API for the client, "hide" the complex type by offering the parameters directly!
    operator fun invoke(name: String, alias: String, mail: String) {
        value = User(name, alias, mail)
    }

    // perhaps some other `invoke`s with convenience parameters!
    operator fun invoke(ldapData: LdapPrincipal) {
        value = User(/* extract the relevant parameters from `LdapPrincipal` instance */)
    }
}

// set the data within some headless-component:
someComponentOrBrick {
    user("Christian", "Chris", "chris@fritz2.org")
}
```

Eine Property sollte immer dann verwendet werden, wenn aus dem Kontext ersichtlich ist, dass die benötigten Daten
aus unterschiedlichen Typen stammen können. Für jeden Typen sollte dann eine passende `invoke`-Funktion angeboten
werden, so dass ein komfortables API für den Benutzer entsteht.

Die Komponente selber kann folgende Aufgaben dann dank der `Property`-Schnittstelle einfach und elegant lösen:

- Prüfen mittels `isSet` ob ein Wert gesetzt wurde. Dies ist wichtig, um ggf. auf einen default-Wert zurückgreifen zu
  können.
- Weiterreichen des Datensatzes an eine andere Property-Instanz per ``use(item: T)``. Dies ist entscheidend für den
  Benutzer, da solche Daten sehr oft auch unmittelbar durch die fertige Komponente öffentlich zur Konfiguration
  exponiert und dann an die Headless-Komponente oder den -Baustein weiter durchgereicht werden müssen.

```kotlin
class SomeSpecificComponent {

    // create Property instance, so external user can provide user data
    val user = UserProperty()

    fun render() {
        someHeadlessComponent() {

            // transfer data into the headless component, which requires it!
            user.use(this@SomeSpecificComponent.user.value)

            someBrick() {
                // `someBrick` might check if `user.isSet` and use some default fallback data by itself!
                // often the component can check and act in the same way too:
                if (user.isSet) {
                    // apply user data
                } else {
                    // act without user data provided
                }
            }
        }
    }
}
```

::: info 
**Tipp:** Wenn es nur einen einzigen Datentypen als Quelle gibt, so sollte man auf eine extra Property-Implementierung
verzichten, und das ganze über eine einfache Konfiguration lösen! 
(vgl. [Ausrichtung von TabGroups](tabgroup/#vertikale-tabgroup))
:::

### Databinding

Einige Headless-Komponenten unterstützen Databinding. Das bedeutet, dass die Komponente auf dynamische Daten von außen
reagiert, diese Daten ggf. intern weiterverarbeitet und nutzt, sowie in der Lage ist, Änderungen auch wieder nach außen
weiterzureichen. Dies entspricht der klassischen Zwei-Wege-Datenbindung, die den Kern von fritz2 ausmacht.

Aufgrund der Wichtigkeit dieses Mechanismus existiert eine spezialisierte `Property` namens `DatabindingProperty<T>`.

Diese Property fordert daher folgende Parameter per `invoke` für die Verwendung:

- `id: String? = null`: Eine optionale ID, welche idR. die Basis für die weiteren Sub-Strukturen einer
  Headless-Komponente bildet.
- `data: Flow<T>`: Muss zwingend angegeben werden. Dieser Datenstrom liefert die dynamischen Daten von außen, auf die
  die Komponente reagieren muss.
- `messages: Flow<List<ComponentValidationMessage>>? = null`: Dieser Datenstrom ermöglicht die optionale Weitergabe von
  Validierungsnachrichten. Viele Headless-Komponenten unterstützen diesen Aspekt bereits nativ!
- `handler: ((Flow<T>) -> Unit)? = null`: Ein optionaler Handler, der definiert, wie die Komponente intern gemachte
  Änderungen wieder nach draußen reichen soll.

Da sich diese Informationen allesamt aus einem `Store` ableiten lassen, bietet die Property eine entsprechend
überladene `invoke`-Methode an.

Damit ermöglicht es diese spezielle Property dem Benutzer, sehr einfach und mit stark reduziertem
Boilerplate-Code, die Daten für die Datenbindung zu exponieren und zu verwalten.

```kotlin
val name = storeOf("fritz2")

inputField {

    // pass the store into the data-binding-property `value`, so that the input-field can be preset with external data
    // and also react to user input to update the external store.
    value(name)

    // ...
}
```

### Hooks

Das Hook-Konzept ist im Kern eigentlich nur eine spezialisierte [Property](#properties), die anstelle von beliebigen
Daten einen sogenannten *Effekt* kapselt. Ein Effekt ist dabei ein Verhalten, das direkte Auswirkungen auf die
Oberfläche hat; sei es durch Strukturen im DOM, oder durch das Reagieren auf Events oder gar dem Erzeugen von Events.

Der Effekt ist im Falle eines Hooks genau die Konfiguration, die vom Benutzer einer Komponente angegeben werden muss,
aber durch die (Headless-)Komponente an einer bestimmten Stelle oder Situation *angewendet* wird.

Daher bietet es sich an, eine `Property` als Basis-Schnittstelle zu wählen: Das öffentliche API zum Setzen des Effekts
funktioniert durch das Property-Konzept analog zu allen anderen Konfigurationen. Der Effekt selber ist hingegen so
gestaltet, dass er als Extension Expression auf einem `Tag` mit einem beliebigen *Payload* Parameter universell
innerhalb des `RenderContexts` aufgerufen werden kann. Obendrein besitzt der Effekt auch einen generischen
Rückgabe-Typ: `typealias Effect<C, R, P> = C.(P) -> R`

Damit kann der Effekt alle Facetten eines UI innerhalb des DOMs abbilden.

Die Konfiguration findet dabei wie gehabt über individuell anzupassende `invoke`-Methoden statt.

Ein immer wieder vorkommendes Muster bei Hooks lässt sich auf die Dualität von statischen und dynamischen Daten
zurückführen: Manchmal ist ein zu rendernder Wert statisch, in anderen Fällen stammt er aus einem `Flow`. Beides kann
man über dedizierte `invoke`-Funktionen abbilden, die entsprechend den Effekt im `value`-Feld der
`Property` ablegen:

```kotlin
class LabelHook : Hook<HTMLElement, Unit, Unit>() {
    operator fun invoke(content: String) = this.apply {
        this.value = {
            // render static content into a label
            label { +content }
        }
    }

    operator fun invoke(content: Flow<String>) = this.apply {
        this.value = {
            // render dynamic content into a label
            label { content.renderText() }
        }
    }
}
```

Eine Komponente bietet den zuvor entwickelten `Hook` über sein öffentliches API zur Konfiguration durch den Benutzer an
und kann den Effekt dann über eine globale `hook`-Funktion einfach anwenden:

```kotlin
class SomeComponent {
    val label = LabelHook()

    fun render() {
        div {
            // apply hook, where needed
            hook(label)
            // further structure...
            input {
                // ...
            }
        }
    }
}

// the user can configure the hook with static content...
someCoponent {
    label("Hooks are great!")
}

// ... or with dynamic content:
val content = storeOf<String>(/* some initial value */)
someComponent {
    label(content.data)
}
```

## Mehrfach genutzte Basisklassen

### Closable Content - OpenClose

Einige der Headless Komponenten können geöffnet und geschlossen werden, beispielsweise indem im geöffneten Zustand
content ausklappt (`disclosure`) oder ein PopUp erscheint (`popOver`). Diese Komponenten implementieren die abstrakte
Klasse `OpenClose`.

Im Scope von dieser Komponenten stehen verschiedene `Flow`s und `Handler` bereit, um auf den Öffnungszustand der
Komponente zu reagieren oder diesen zu beeinflussen:

- `opened: Flow<Boolean>` beschreibt, ob die Komponente geöffnet oder geschlossen ist
- `open : Handler<Unit>` öffnet die Komponente
- `close : Handler<Unit>` schließt die Komponente
- `toggle : Handler<Unit>` schließt die Komponente, wenn sie geöffnet ist und andersherum

Der Öffnungszustand einer solchen Komponente kann über die Property `openClose` per Databinding z.B. an einen
externen `Store` oder `Flow` gebunden werden. Über diesen kann z.B. die Sichtbarkeit der Auswahlliste einer `listbox`
dann unabhängig vom Standardverhalten gesteuert werden, also z.B. immer offen gehalten werden:

```kotlin
listbox<String> {
    //...

    listboxItems {
        openClose(data = flowOf(true))

        characters.forEach { entry ->
            listboxItem(entry) {
                //...
            }
        }
    }
}
```

### Floating Content - PopUpPanel

Einige Bausteine der Headless Komponenten (z.B. das `popOverPanel` oder die `listboxItem`) werden dynamisch positioniert
und schweben über dem übrigen Inhalt. Oft werden diese auch dynamisch ein- und ausgeblendet.

Diese Bausteine sind mit Hilfe der Bibliothek [Popper.js]("https://popper.js.org/") realisiert. Dementsprechend bieten
sie eine einheitliche Konfigurationsschnittstelle, um die wichtigsten Attribute

Im Scope eines solchen Bausteins, der die abstrakte Klasse `PopUpPanel` implementiert, stehen folgende Konfigurationen
zur Verfügung, um die Positionierung des Inhaltes zu beeinflussen:

- `placement` definiert die Position des Bausteins, z.B. `Placement.top`, `Placement.bottomRight`, etc. Standardwert
  ist `Placement.auto`. Hierbei wird die vermutlich beste Position automatisch anhand des zur Verfügung stehenden
  sichtbaren Platzes bestimmt.
- `strategy` legt fest, ob der Baustein `absolute` positioniert werden soll (default) oder `fixed`.
- `flip` kommt der Baustein zu nah an den Rand des sichtbaren Bereichs, wechselt die Position automatisch auf die
  jeweils andere Seite, wenn dort mehr Platz zur Verfügung steht.
- `distance` definiert den Abstand der Auswahlliste vom Referenzelement in Pixeln. Der Standardwert ist 10.
- `skidding` definiert die Verschiebung der Auswahlliste entlang des Referenzelements in Pixeln. Der Standardwert ist 0.

